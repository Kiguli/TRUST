\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage{IEEEtrantools}
\usepackage{latexsym,amsfonts,amsmath} %amssymb
\usepackage{graphicx}
\usepackage{dsfont}
\usepackage{enumerate}
\usepackage{hyperref}
\newtheorem{claim}{Claim}
\newtheorem{problem}{Problem}
\newtheorem{algorithm}{Algorithm}
\newtheorem{construction}{Construction}
\newtheorem{xca}{Exercise}
\newtheorem{comments}{Comments}
\newtheorem{remark}{Remark}
\newtheorem{assumption}{Assumption}
\newtheorem{fact}{Fact}

\usepackage{mathrsfs}

\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage{algpseudocode}
%================FAUST
\usepackage{xspace}
\newcommand{\software}{\textsf{FAUST}$^{\mathsf 2}$\xspace}
%=================

\newcommand{\set}[1]{{\{#1 \}}}
\newcommand{\boxspan}{\mathit{span}}
\newcommand{\params}{{\mathsf{q}}}
\renewcommand{\Re}{{\mathbb{R}}}
\newcommand{\R}{{\mathbb{R}}}
\newcommand{\F}{{\mathbb{F}}}
\newcommand{\Q}{{\mathbb{Q}}}
\newcommand{\Ze}{{\mathbb Z}}
\newcommand{\B}{{\mathbb B}}
\newcommand{\Ce}{{\mathbb C}}
\newcommand{\N}{{\mathbb{N}}}
\newcommand{\T}{{\mathbb T}}
\newcommand{\fs}{{\mathbb S}}
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\ea}{\textit{et al}}
\newcommand{\D}{\displaystyle}
\newcommand{\Pre}{\mathrm{Pre}}
\newcommand{\Post}{\textrm{Post}}
\newcommand{\argmax}{\textrm{arg}\max}
\newcommand{\argmin}{\textrm{arg}\min}
\newcommand{\UP}{\textrm{UP}}
\newcommand{\X}{{\mathbf{X}}}
\newcommand{\Next}{{\mathrm{Next}}}
\newcommand{\Inv}{{\mathrm{Inv}}}
\newcommand{\Reach}{{\mathrm{Reach}}}
\newcommand{\kr}{\textrm{ker}}
\newcommand{\s}{\mathrm{span}}
\renewcommand{\dim}{\mathrm{dim}}
\newcommand{\lie}{\mathrm{Lie}}
\newcommand{\cl}{\mathrm{cl}}
\newcommand{\inte}{\mathrm{int}}
\newcommand{\bd}{\mathrm{bd}}
\newcommand{\E}{\mathrm{End}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\p}{\mathsf{p}}
\newcommand\norm[1]{\left\lVert#1\right\rVert}

\DeclareMathOperator{\Tr}{Tr}
\newcommand{\note}[1]{\textcolor{red}{(#1)}}
\newcommand{\ra}{\rightarrow}
\newcommand{\insertref}{\textcolor{red}{[ref]}}
\newcommand{\ul}{\underline}
\newcommand{\ol}{\overline}
\newcommand{\Let}{:=}
\newcommand{\EE}{\mathds{E}}
\newcommand{\PP}{\mathds{P}}
\newcommand{\traj}[3]{#1_{#2#3}}
\newcommand{\red}[1]{{\color{red}{#1}}}
\newcommand{\blue}[1]{{\color{blue}{#1}}}
\newcommand{\BW}{\textcolor{red}}
\newcommand{\MZ}[1]{{\textcolor{red}{ \textbf{MZ:} #1}}}

\newcommand{\intcc}[1]{\ensuremath{{\left[#1\right]}}}
\newcommand{\intoc}[1]{\ensuremath{{\left]#1\right]}}}
\newcommand{\intco}[1]{\ensuremath{{\left[#1\right[}}}
\newcommand{\intoo}[1]{\ensuremath{{\left]#1\right[}}}

%\linespread{0.9}

\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\ess}{ess}

\newcommand{\id}{{\mathrm{id}}}
\renewcommand{\emptyset}{{\varnothing}}
\newcommand{\Abolfazl}{\textcolor{blue}}

\newcommand{\identity}{\mathbb{I}}
% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\newcommand{\initial}{X_I}
\newcommand{\unsafe}{X_U}

% DOI
%\acmDOI{10.475/123_4}

% ISBN
%\acmISBN{123-4567-24-567/08/06}

%Conference
%\acmConference[HSCC'18]{ACM International Conference on Hybrid Systems: Computation and Control }{April 2018}{Porto, Portugal}
%\acmYear{2018}
%\copyrightyear{2018}

%\acmPrice{15.00}


\begin{document}
\copyrightyear{2025}
\acmYear{2025}
\setcopyright{acmlicensed}
\acmConference[HSCC'25]{28th ACM International Conference on Hybrid Systems: Computation and Control, Irvine, California, May 6-9 2025}
\acmBooktitle{May 6-9 2025, Irvine, California, USA}
%\acmPrice{15.00}
%\acmDOI{10.1145/3178126.3178135}
%\acmISBN{978-1-4503-5642-8/18/04}


\title[TRUST: Controller Synthesis for Black-Box Systems Using a Single Trajectory]{TRUST: Stabili\underline{\textbf{T}}y and Safety Cont\underline{\textbf{R}}oller Synthesis for Black-Box Systems \underline{\textbf{U}}sing a \underline{\textbf{S}}ingle \underline{\textbf{T}}rajectory}

\author{Jamie Gardner}
\affiliation{%
    \institution{School of Computing}
    \institution{Newcastle University}
}
\email{j.gardner3@newcastle.ac.uk}

\author{Ben Wooding}
\affiliation{%
    \institution{School of Computing}
    \institution{Newcastle University}
}
\email{ben.wooding@newcastle.ac.uk}

\author{Amy Nejati}
\affiliation{%
    \institution{School of Computing}
    \institution{Newcastle University}
}
\email{amy.nejati@newcastle.ac.uk}

\author{Abolfazl Lavaei}
\affiliation{%
    \institution{School of Computing}
    \institution{Newcastle University}
}
\email{abolfazl.lavaei@newcastle.ac.uk}

\begin{abstract}
TRUST is an open-source software tool for the single-trajectory data-driven control synthesis for Stability and safety barrier certificates (BCs).
The tool implements sum-of-squares (SOS) optimizations for the systematic production of both linear and polynomial BCs. By ensuring the persistently-excited state of the input data, which is determined by fulfilling a certain rank condition, the system will compute the stability functions and safety barrier certificates and their respective controllers for an infinite time horizon from the finite-length dataset.

The stability and safety properties are calculated for four classes of dynamical systems: (i) continuous-time nonlinear polynomial systems, (ii) continuous-time linear systems, (iii) discrete-time nonlinear polynomial systems, and (iv) discrete-time linear systems.
For each of these four scenarios, TRUST can synthesize the stability function and controller or the safety barrier certificate and controller.

TRUST is a Python-based web application, providing an intuitive and reactive GUI via web technologies, and can be accessed at <URL> or installed locally, and supports both manual data entry and data file uploads.
The tool uses the SOS optimization toolbox to solve the stability and safety barrier problems, and the symbolic programming library SymPy to handle the symbolic computations.
Leveraging the power of the Python backend and Javascript frontend, the tool is designed to be user-friendly and accessible on desktop, tablet, and mobile devices.
Physical case studies validate our data-driven approach for each of the four pairs of scenarios.
\end{abstract}

% The code below should be generated by the tool at
% https://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.

\begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10003752.10003790.10011119</concept_id>
% <concept_desc>Theory of computation~Abstraction</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10010520.10010553</concept_id>
% <concept_desc>Computer systems organization~Embedded and cyber-physical systems</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10003033.10003039.10003041.10003043</concept_id>
% <concept_desc>Networks~Formal specifications</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>

\end{CCSXML}

%\ccsdesc[500]{Theory of computation~Abstraction}
%\ccsdesc[500]{Computer systems organization~Embedded and cyber-physical systems}
%\ccsdesc[300]{Networks~Formal specifications}


\keywords{Data-Driven Control Synthesis, Safety Verification, Barrier Certificates}


\maketitle


\section{introduction}\label{sec:introduction}

\subsection{Motivation for TRUST}\label{subsec:motivation-for-sintra-sb}

% Opening paragraphs.
% Look at previous works like PRoTECT (and other data-driven approaches from Abolfazl's website). Don't worry about coming up with this, just paraphrase and rewrite from the existing works.
The design of control systems that ensure stability and safety is a fundamental problem in control theory, with applications in safety-critical systems including robotics, aerospace, self-driving cars, and medical devices, to name a few.
Traditional model-based approaches to control synthesis rely on accurate mathematical models of the system dynamics, which are often difficult to obtain, or may not accurately reflect the real-world behavior of the system.
In contrast, data-driven methods have gained popularity due to their ability to handle unknown mathematical models based on the data collected from the system~\cite{nejati2023data}.

%I. Stability
%    A. Introduce the concept of stability in dynamical systems (i.e. what the Lyapunov function is)
%    B. Discuss the importance of stability in control synthesis (we deal with asymptotic stability, where we return to a stable equilibrium rather than just stay at it)
A system is considered stable if it either remains at an equilibrium point or returns to it after a disturbance, known as asymptotic stability.
In control synthesis, stability is crucial for ensuring that the system behaves as intended, and does not deviate from its desired behavior.
This assurance comes from the calculation of a Lyapunov function for a system, which serves as a fundamental guarantee across the system's continuous-state space~\cite{breschi2021direct}.

%II. Safety Barrier
%    A. Introduce the concept of safety barrier certificates (we deal with control barrier certificates, where the user can provide the control data, i.e.\ U0)
%    B. Explain how safety barrier certs are particularly useful in safety-critical systems, where the system not only needs to be stable but also avoid unsafe regions
%    C. Note the use of Sum of Squares (SOS) optimization techniques
In addition to stability, safety barrier certificates formalise the notion of safety in dynamical systems, by ensuring that the system will never enter an unsafe region across an infinite time horizon.
Control barrier certificates (CBCs) are particularly useful for real-world systems, where the data is directly measured through input-output observations, known as a ``single trajectory''~\cite{ren2024formal}.

%III. Data-driven (single-trajectory)
%    A. Highlight the issue with traditional model-based approaches for stability or safety barriers
%        1. The system model is assumed to be known, which isn't realistic.
%    B. Introduce data-driven approaches
%        1. More realistic
%        2. Often require large amounts of data, over many trajectories (order of magnitude in the millions)
%        3. Often requires the data to be independent and identically distributed (i.i.d.)
%    C. Introduce the concept of single-trajectory data-driven control synthesis
%        1. Use of persistently-excited (full rank) data allows for the system to be analyzed and controlled using a single trajectory
%        1. Reduction in complexity
%        2. Reduction in data requirements

% We can go into detail about how a single trajectory can be used to synthesize both the Lyapunov function and the barrier certificate.
% - Motivate the tool by highlighting the gap in current tooling. Start by referencing the orginal barrier certificate and stability works. Lead into data-driven tools which are more realistic, but expensive to get the correct data for, so tools should to work accurately with less data, which is where our approach differs.
% DPT19, ACE+19, KMS+24, MTZ22, NZ23, NZCZ22, PR07, SLSZ24, WRMDM05, WMPDP24, XCB23, BDPT20] also cite PRoTECT, FOSSIL, and any other barrier or data tools in the literature, and Benâ€™s data paper [AAE+21, WHL24, KMS+24].

% - Discuss what exactly the Lyapunov function is, as the foundational problem, in terms of what data is needed and how to compute the stability of a system.
% - Follow by specifically exploring Control Barrier Certificates (CBCs) which extend the stability (aka Lyapunov) function for level sets that segment the state space into an initial, safe space and one or more unsafe states.
% - Briefly interlude with the distinction of discrete- vs continuous-time systems (references?)
% - Where does the the differences between linear and nonlinear polynomial systems fit in here?
% The Lyapunov function is particularly useful for analyzing discrete-time systems, where it can be used to determine the behavior of a dynamical system based on its state sequence at each time step.
% However, for continuous-time systems, analysis becomes more complex due to the need for persistence of excitation.

% - Reference Willems' fundamental lemma for "the concept of persistence of excitation" for continuous-time nonlinear polynomial systems
Willems' Fundamental Lemma provides a necessary condition for the existence of a stability function for continuous-time non-linear polynomial systems~\cite{willems2005note}, thus enabling the design of safety barrier certificates for these systems.
% Include a reference to Sum of Squares optimisation for the computation of the safetyb barrier certificate here?
The computation of these safety barrier certificates can be performed using Sum of Squares (SOS) optimization techniques, using an existing toolbox~\cite{prajna2002introducing}.
It is worth noting that despite many works on the subject of \emph{continuous-time} nonlinear polynomial systems~\cite{bisoffi2020data,bisoffi2022controller,nejati2022data}, few works deal with the more difficult production of results for single-trajectory \emph{discrete-time} non-linear polynomial systems~\cite{martin2023guarantees}.
% - Reference Behrad's paper for the solution to discrete-time nonlinear polynomial system safety
Despite this lack of research, this work implements a cutting-edge theoretical discovery on data-driven methods for the design of stable and safe controllers for this category of system~\cite{samari2024single}.
% - The problem: Finish the paragraph with the challenge of control synthesis for unknown mathematical models
% With this theoretical context in mind, the practical, real-world synthesis of a stable controller, and by extension a safe controller, is quite challenging, especially when the mathematical model of the system is unknown.
However, practical implementation of this research remains scarce, due to the complexity of real-world scenarios where the mathematical model of the system is unknown, or it is expensive in terms of manual effort to first identify and then solve the problem using model-based methods.

% - The solution: Refer to the intro in Behrad's paper for an intro to the use of data-driven techniques as a reduction in the layers of complexity of the problem, and further how single trajectories and excited states can reduce the amount of data required.
As a solution, data-driven techniques offer a promising reduction in cost and complexity, by leveraging

% - Break the solution down into its two parts: reduction in complexity, and reduction in data
- Clarify the complexity e.g. the problems like "linear quadratic regulation and robust controller design" (rephrase and reuse the references); "model-reference controller design for linear dynamical systems" (same as previous); "stabilization of polynomial systems" (and again); and how these approaches don't account for state constraints (i.e. the level sets - clarify the relevance?);

- Then by clarifying the data requirements e.g. other scenario-based programs that require independent and identically distributed (i.i.d.) data which requires the collection of multiple trajectories (in the order of magnitude of millions)

% - Lead this into the lack of tooling in the area
Recent studies have proposed various data-driven methods for this problem (reference PRoTECT, IMPaCT and FOSSIL), which are much more realistic than traditional model-based approaches.
However, these methods often require a large amount of data to provide accurate guarantees (reference), making them impractical for many real-world applications.

- Then highlight this gap that SinTra fills, i.e. synthesizing stability functions and safety barrier certificates using persistently-excited, single-trajectory data.

- Outline the benefits of this tool in terms of the formal guarantees it provides, including the breadth of scenarios for both stability and the extended problem of CBCs.

\subsection{Related Literature}\label{subsec:related-literature}

\subsection{Related Software}\label{subsec:related-software}
- Discuss the existing tools in the area, including PRoTECT, IMPaCT, and FOSSIL, and how they differ from SinTra.

\subsection{Contributions}\label{subsec:contributions}
This tool paper contributes the following novel and noteworthy developments:
%- Review how specifically SinTra fits these needs when able to determine a persistently excited state, and detail what exactly this means, before bringing the user back to the novel contribution.
%- despite finite trajectories considered, the guarantees hold over infinite horizons. Nice interface. Stability and Safety guarantees. etc.
%- Unique contributions are primarily the tool being data-driven, but also by verifying that the samples are persistently excited, we can use single-trajectory data over a fixed time horizon whilst still providing (probabilistic) guarantees for an infinite time horizon, drastically reducing the data required in our tool. Additionally, our tool covers the breadth of scenarios for continuous time and discrete time linear and nonlinear polynomial, all in the one tool.
\begin{enumerate}[i.]
\item TRUST is a first-of-its-kind tool that uses data-driven approaches to synthesize stability functions and safety barrier certificates from a single-trajectory.
\item Implemented as a responsive and reactive Flask web application, TRUST provides an intuitive and user-friendly interface for users to interact with the tool.
\item Real-time client-side updates and error management through asynchronous JavaScript and XML (AJAX) requests provide a seamless user experience across any platform.
\item The server-side Python application leverages the Flask web framework to handle the data processing and computation of the stability functions and safety barrier certificates, following an MVC architecture and test-driven development for high-quality code.
\item TRUST extends the Sum of Squares (SOS) optimization toolbox powered by MOSEK to solve the stability and safety barrier problems for continuous-time and discrete-time linear and nonlinear polynomial systems using the symbolic programming library SymPy.
\item The tool allows for both manual data entry and data file uploads for the X0, U0 and X1 datasets, a simple user experience for defining the state space, initial set, and multiple unsafe sets of the system, and, for nonlinear polynomial systems, the monomial terms.
\item We demonstrate the usefulness of TRUST through eight distinct scenarios, representing the four classes of dynamical system, and their respective stability functions and safety barrier certificates.
\end{enumerate}

\subsection{Structure of the Paper}\label{subsec:structure-of-the-paper}
This paper is structured as follows:
\begin{enumerate}
\item \hyperref[sec:introduction]{Introduction}: provides the necessary background information on stability functions and safety barrier certificates, and the data-driven approach to control synthesis.
\item \hyperref[sec:overview-of-the-tool]{Overview of the Tool}: gives an overview of the TRUST tool, including the notation used, the inputs required, and the outputs produced.
\item \hyperref[sec:problem-description]{Problem Description}: outlines the problem of stability and safety control synthesis for black-box systems using a single trajectory.
\item \hyperref[sec:scenarios]{Scenarios}: presents the four primary scenarios for continuous-time and discrete-time linear and nonlinear polynomial systems, demonstrating the tool's capabilities.
\item \hyperref[sec:benchmarks-and-case-studies]{Benchmarks and Case Studies}: provides a detailed analysis of the tool's performance through a series of benchmarks and case studies.
\item \hyperref[sec:results]{Results}: presents the results of the benchmarks and case studies, highlighting the tool's effectiveness in solving stability and safety problems.
\end{enumerate}

% -- Section 2 --

\section{Overview of the Tool}\label{sec:overview-of-the-tool}

\subsection{Notation}\label{subsec:notation}
$\mathbb{R}$, $\mathbb{R}^+_0$, and $\mathbb{R}^+$ denote the set of real numbers, non-negative and positive real numbers, respectively. $\mathbb{N}$ and $\mathbb{N}^+$ denote the set of natural numbers including and excluding zero. $\emptyset$ denotes the empty set.
The notation $\mathbb{R}^{a\times b}$ in general is used to describe a matrix of size $a\times b$ that contains real values, equivalently $\mathbb{N}^{a\times b}$ for natural numbers.
Similarly, a vector of size $n$ is denoted with $\mathbb{R}^n$ or $\mathbb{N}^n$. $A^{-1}$ and $A^\top$ are respectively the inverse and the transpose of matrix $A$.
We use $[a,b]$ for the closed set between $a$ and $b$.

\subsection{Inputs to the tool}\label{subsec:inputs-to-the-tool}

\subsubsection{Modes of the Tool}

\textsf{TRUST} is valuable in solving two main types of problems:
\begin{enumerate}
\item \emph{Stability problems} - synthesizing a control Lyapunov function $\mathcal{V}(x)$ to show stability of the underlying system;
\item \emph{Safety barrier problems} - synthesizing a control barrier certificate $\mathcal{B}(x)$ to guarantee safe behavior of the underlying system.
\end{enumerate}
In addition to these two modes that assume the presence of control inputs,  \textsf{TRUST} can satisfy the same problems without control inputs, which are simpler cases for both modes.
Therefore, all parameters relating to the controller or control inputs are optional.

\subsubsection{Classes of Systems}

\textsf{TRUST} can handle four main classes of systems; discrete-time linear systems (dt-LS), continuous-time linear systems (ct-LS), discrete-time nonlinear polynomial systems (dt-NPS) and continuous-time nonlinear polynomial systems (ct-NPS). It can handle each of these classes of systems for both the generation of stability functions and safety barrier certificates and their respective controllers.

\subsubsection{Datasets (\texttt{*.csv}, \texttt{*.txt}, \texttt{*.json})}
\textsf{TRUST} takes in as input the necessary datasets that together contain a \emph{persistently excited} data trajectory, these are expected to be in one of the following common data file extensions; \texttt{*.csv}, \texttt{*.txt}, or \texttt{*.json}.
The data should be sequential over a time horizon of $T\in\mathbb{N}^+$ steps, and may have multiple state dimensions $n\in\mathbb{N}^+$ and input dimensions $m\in\mathbb{N}$.
In the discrete-time cases, the datasets can be represented as:
\begin{align}
\label{eq:data-discrete}
\begin{cases}
&\mathcal{X}_{0} = [x(0),x(1),x(2),\ldots,x(T-1)],\\
&\mathcal{U}_{0} = [u(0),u(1),u(2),\ldots,u(T-1)],\\
&\mathcal{X}_{1} = [x(1),x(2),x(3),\ldots,x(T)],
\end{cases}
\end{align}
where $\mathcal{X}_{0}$ is generally the predecessor states, $\mathcal{X}_{1}$ is generally the successor states, and if there are control inputs they are captured by $\mathcal{U}_{0}$.

\begin{remark}
We remark that the tool can handle $m=0$ when there is no input present, the theoretical results remain largely the same~\BW{[cite my k-inductive paper]} with the key difference being no controller $u$ is designed.
In such a situation $\mathcal{U}_{0}$ is omitted completely.
\end{remark}

In a small abuse of notation, the continuous-time data is again sequential as:
\begin{align}
\label{eq:data-continuous}
\begin{cases}
&\mathcal{X}_{0} = [x(0),x(\tau),x(2\tau),\ldots,x((T-1)\tau)],\\
&\mathcal{U}_{0} = [u(0),u(\tau),u(2\tau),\ldots,u((T-1)\tau)],\\
&\mathcal{X}_{1} = [\dot{x}(0),\dot{x}(\tau),\dot{x}(2\tau),\ldots,\dot{x}((T-1)\tau)],
\end{cases}
\end{align}
where $\tau$ is a fixed sampling time for the system.
Additionally, $\mathcal{X}_{1}$ contains the derivatives of the state at each sampling time.
\begin{remark}
In practice, these derivatives are likely to be approximated, any error handling relating to this approximation is left to the user.
\end{remark}


\textsf{TRUST} will check that the data satisfies a rank condition that ensures the data is persistantly excited.
This rank condition is defined as~\cite{de2019formulas}

\begin{equation}
\label{eq:rank}
\text{rank}\begin{bmatrix}
\mathcal{U}_0 \\
\hline
\mathcal{X}_0
\end{bmatrix} = n+m.
\end{equation}

\subsubsection{Monomials (polynomials in $x$)}
\emph{For nonlinear polynomial systems}, the user should provide a matrix of monomial terms $\mathcal{M}(x)$.
As an example, of this when $x\in\mathbb{R}^2$: $\mathcal{M}(x) = \begin{bmatrix}
x_1^2 &
x_1 x_2 &
x_2
\end{bmatrix}^\top$
where here the number of monomial terms is $N=3$ and $N\in\mathbb{N}^+$.

\subsubsection{Definitions of initial set $X_I$ , unsafe set $X_U$, state space $X$}
For safety barrier problems, the user should define the state space $X$, initial set $X_I$ and unsafe set $X_U$ of the system using hypercubes for the \emph{semi-algebraic sets}~\cite{parrilo2003semidefinite}.
Since they are semi-algebraic, the hypercubes can be described as vectors of polynomials respectively $g_I(x), g_U(x)$ and $g(x)$. \textsf{TRUST} collects the lower bound and the upper bound for each dimension to construct the hypercube.

\subsection{Outputs from Tool}\label{subsec:outputs-from-tool}

The outputs of \textsf{TRUST} will depend on the mode chosen.
For stability problems, \textsf{TRUST} will output a Lyapunov function $\mathcal{V}(x)$ based on the data or for safety barrier problems the safety barrier certificate $\mathcal{B}(x)$ and its level sets $\gamma$ and $\lambda$.
If either cannot be synthesized then \textsf{TRUST} will return some sort of error message.

In both modes the functions, $\mathcal{V}(x)$ or $\mathcal{B}(x)$, are quadratic of the form $x^\top Px$ in the majority of cases and $\mathcal{M}(x)^\top P\mathcal{M}(x)$ in the continuous-time nonlinear polynomial case, where $P\succ 0$ is a symmetric positive definite matrix.
For problems that include data for control inputs $\mathcal{U}_{0}$, we will also return to the user the controller, $u\in\mathbb{R}^m$, synthesized for $\mathcal{V}(x)$ or $\mathcal{B}(x)$.


\section{Problem Description}\label{sec:problem-description}

- A few paragraphs that outline the problem to the reader
- Specifically, detail the notations and definitions used (stability function, barrier function)
- Concisely describe the tool in terms of applications and underlying algorithms (web-based UI, SOS toolbox, symbolic programming)
- Pseudocode of the tool
- Touch on the web stack at a high level as the entry point to the system
- Focus more on the hierarchy of the problems, i.e. the simultaneous equations to solve for P and H, before the SOS conditions.


\section{Scenarios}\label{sec:scenarios}

- Introduce the four systems, each with their safety function and stability barrier function alternatives.
- Include the controller synthesis in each case
- Add a marked-up screenshot of the tool, highlighting each region
- three columns, first for data entry, second for state definitions, third for output
- footer with the title and description, and the primary Calculate action

%We first define generally the conditions required to find model-based control barrier certificates (CBC) for continuous-time systems, we will then demonstrate how these conditions are used in the data-driven section for the different classes of continuous systems that follow as well as the stability conditions for each of these classes of system.
We remind the reader that the data considered in this section is of the form in equation~\eqref{eq:data-continuous}.

\subsection{Continuous Time Nonlinear Polynomial Systems}\label{subsec:continuous-time-nonlinear-polynomial-systems}
We consider continuous-time nonlinear polynomial systems (ct-NPS) defined as follows:

\begin{definition}
\label{def:system-description-ct-NPS}
A ct-NPS is described by the ordinary differential equation
\begin{equation}
\label{eq:ct-NPS}
\Sigma_c: \dot{x} = A\mathcal{M}(x)+Bu
\end{equation}
where $A\in\mathbb{R}^{n\times N}$ and $B\in\mathbb{R}^{n\times m}$ are unknown, $\mathcal{M}(x)\in\mathbb{R}^N$ is a vector of monomials in state $x\in X$, and $u\in U$ is a control input, with $X\subset\mathbb{R}^n$, and $U\subset\mathbb{R}^m$ being the state and input sets, respectively.
\end{definition}

We now present the following lemma, taken from~\cite{nejati2022data}, to obtain a data-based representation of closed-loop ct-NPS~\eqref{def:system-description-ct-NPS} with controllers $u=K(x)\mathcal{M}(x)$, where $K(x)\in\mathbb{R}^{m\times N}$ is a matrix polynomial, which will be synthesized.

\begin{lemma}[ct-NPS Q-Lemma~\cite{nejati2022data}]
\label{lem:Q-ctNPS}
Let matrix polynomial $Q(x)$ be a $(T\times N)$ matrix such that
\begin{equation}
\label{eq:Q-matrix-ctNPS}
\mathbb{I}_n = \mathcal{N}_{0}Q(x),
\end{equation}
with
\begin{equation}
\label{eq:data-N0T}
\mathcal{N}_{0} = [\mathcal{M}(x(0)), \mathcal{M}(x(\tau)), \mathcal{M}(x(2\tau)), \ldots, \mathcal{M}(x((T-1)\tau))]
\end{equation}being an $(N\times T)$ full row-rank matrix.
If one sets $u=K(x)\mathcal{M}(x) = \mathcal{U}_{0}Q(x)\mathcal{M}(x)$, then the closed-loop system $\dot{x}=A\mathcal{M}(x)+Bu$ has the following data-based representation:
\begin{equation}
\label{eq:A+BK=X1TQ-ctNPS}
\dot{x} = \mathcal{X}_{1}Q(x)\mathcal{M}(x),\quad\text{equivalently,}\quad A+BK(x) = \mathcal{X}_{1}Q(x).
\end{equation}
\end{lemma}

Using the above lemma, we now have a data-driven representation of our system using $\mathcal{X}_{1}Q(x)\mathcal{M}(x)$, which we will use to design controllers for CBCs and stability in the following theorems.

\subsubsection{Control Barrier Certificate}

\begin{theorem}[Data-Driven ct-NPS CBC~\cite{nejati2022data}]
\label{thm:data-ctNPS-CBC}
Consider the unknown ct-NPS~\eqref{eq:ct-NPS}, \emph{i.e.} $\dot{x} = A\mathcal{M}(x)+Bu$, with its data-based representation $\dot{x}=\mathcal{X}_{1}Q(x)\mathcal{M}(x)$.
Suppose there exists a positive definite symmetric matrix $P\in\mathbb{R}^{n\times n}$ and relationship $Q(x)=H(x)P$ such that the following conditions are satisfied
\begin{align}
\label{eq:ctNPS_CBC_data1}
\mathcal{M}(x)^\top [\mathcal{N}_{0}H(x)]^{-1}\mathcal{M}(x) \leq \gamma, &\quad\forall x\in X_I, \\
\label{eq:ctNPS_CBC_data2}
\mathcal{M}(x)^\top [\mathcal{N}_{0}H(x)]^{-1}\mathcal{M}(x) \geq \lambda, &\quad\forall x\in X_U,
\end{align}
and $\forall x\in X$,
\begin{align}
\label{eq:ctNPS_CBC_data3}
\frac{\partial M}{\partial x}\mathcal{X}_{1}H(x) + H(x)^\top\mathcal{X}_{1}^\top(\frac{\partial M}{\partial x})^\top &\leq 0,\\
\label{eq:ctNPS_CBC_data0}
\mathcal{N}_{0}H(x)&=P^{-1}.
\end{align}
Then $\mathcal{B}(x) = \mathcal{M}(x)^\top [\mathcal{N}_{0}H(x)]^{-1}\mathcal{M}(x)$ is a CBC and \newline $u = \mathcal{U}_{0}H(x)[\mathcal{N}_{0}H(x)]^{-1}\mathcal{M}(x)$ is its corresponding safety controller for the unknown ct-NPS.
\end{theorem}

\subsubsection{Sum-of-Squares Formulation}
\BW{Add a reference for this formulation.} We present now how to solve equations~\eqref{eq:ctNPS_CBC_data1}-\eqref{eq:ctNPS_CBC_data0} in this first occurrence of the conditions, the CBC conditions for later sections follow similarly but are omitted for brevity.

We now introduce $L_I(x),L_U(x),L(x)$ as vectors of SOS polynomials.
We can solve the following using the SumOfSquares toolbox~\cite{Yuan_SumOfSquares_py} where we also add an additional LMI constraint for the equality~\eqref{eq:ctNPS_CBC_data0}.

We consider~\eqref{eq:ctNPS_CBC_data0}
and the following are sum-of-squares
\begin{align}
\label{eq:ct-SOS1}
-\mathcal{M}(x)^\top [\mathcal{N}_{0}H(x)]^{-1}\mathcal{M}(x) -& L_I^\top(x)g_I(x) + \gamma, \\
\label{eq:ct-SOS2}
\mathcal{M}(x)^\top [\mathcal{N}_{0}H(x)]^{-1}\mathcal{M}(x) -& L_U^\top(x)g_U(x) + \lambda, \\
\label{eq:ct-SOS3}
-[\frac{\partial M}{\partial x}\mathcal{X}_{1}H(x) + H(x)^\top\mathcal{X}_{1}^\top(\frac{\partial M}{\partial x})^\top] -& L^\top(x)g(x).
\end{align}

% We should know $\frac{\partial M}{\partial x}$ since the monomials $M(x)$ are already given to us.

% To solve first find solutions to
% \begin{equation*}
%     P^{-1} = \mathcal{N}_{0}H(x)
% \end{equation*}
% and
% \begin{equation*}
%     -[\frac{\partial M}{\partial x}\mathcal{X}_{1}H(x) + H(x)^\top\mathcal{X}_{1}^\top(\frac{\partial M}{\partial x})^\top]\geq 0
% \end{equation*}
% then solve the sum of squares conditions to find $\gamma$ and $\lambda$. Then the barrier certificate is given by $\mathcal{B}(x) = \mathcal{M}(x)^\top [\mathcal{N}_{0}H(x)]^{-1} \mathcal{M}(x)$ and the controller by $u = \mathcal{U}_{0}H(x)(\mathcal{N}_{0}H(x))^{-1}M(x)$, we also return $\gamma$ and $\lambda$.

A hierarchical approach to solve Theorem~\ref{thm:data-ctNPS-CBC} is used where first $H(x)$ and $P$ are found in equations~\eqref{eq:ctNPS_CBC_data3}-\eqref{eq:ctNPS_CBC_data0} before equations~\eqref{eq:ctNPS_CBC_data1}-\eqref{eq:ctNPS_CBC_data2} are solved using SOS programming for $\gamma$ and $\lambda$.
This is shown in Algorithm~\ref{alg:ct-nonlinear}.

\begin{algorithm}[t]
\caption{Hierarchy for ct-NPS CBCs}\label{alg:ct-nonlinear}
\begin{algorithmic}[1]
\Require $\mathcal{X}_0,\mathcal{X}_1,\mathcal{U}_0,X,X_I,X_U, \mathcal{M}(x)$
\Ensure \eqref{eq:rank} holds
\Ensure semi-algebraic $X,X_I,X_U$
\State Solve~\eqref{eq:ctNPS_CBC_data3} and~\eqref{eq:ctNPS_CBC_data0} for $H(x)$ and $P$ via LMIs
%\State Solve~\eqref{eq:Q-matrix-X0} for $Q$
\State Substitute and solve~\eqref{eq:ctNPS_CBC_data1}-\eqref{eq:ctNPS_CBC_data2} via SOS optimization~\eqref{eq:ct-SOS1}-\eqref{eq:ct-SOS3}
\noindent\Statex\textbf{Return:} CBC $\mathcal{B}(x)$, Controller $u$
\end{algorithmic}
\end{algorithm}

\subsubsection{Stability}

Solving only the last CBC conditions~\eqref{eq:ctNPS_CBC_data3}-\eqref{eq:ctNPS_CBC_data0} with no restriction over a state space $X$ renders the stability problem.

\begin{theorem}[ct-NPS Stable Controller Design]
\label{thm:ctNPS-stable}
A control Lyapunov function $\mathcal{V}(x)=\mathcal{M}(x)^\top P\mathcal{M}(x)$ guaranteeing stability of the ct-NPS~\eqref{eq:ct-NPS} can be designed by introducing the new variable
\begin{equation*}
\label{eq:Q=HP-ctNPS}
Q(x)=H(x)P,
\end{equation*}
so that any polynomial matrices $H(x)\in\mathbb{R}^{T\times N}$, and $P\in\mathbb{R}^{N\times N}$ satisfying
\begin{align}
\label{eq:stability-ctNPS}
\frac{\partial M}{\partial x}\mathcal{X}_{1}H(x) + H(x)^\top\mathcal{X}_{1}^\top(\frac{\partial M}{\partial x})^\top \prec 0, \quad \mathcal{N}_{0}H(x)=P^{-1}
\end{align}
stabilize~\eqref{eq:ct-NPS}.
The controller is given by~\newline$u=\mathcal{U}_{0}Q(x)\mathcal{M}(x) = \mathcal{U}_{0}H(x)[\mathcal{N}_{0}H(x)]^{-1}\mathcal{M}(x).$
\end{theorem}

We remark here that the stability conditions are straightforward to solve using semidefinite programming solvers such as SEDUMI or Mosek \BW{cite whichever we use, and remove the other}. The psuedocode for ct-NPS stability is given in Algorithm~\ref{alg:ct-stab}.

\begin{algorithm}[t]
\caption{Hierarchy for ct-NPS Stability}\label{alg:ct-stab}
\begin{algorithmic}[1]
\Require $\mathcal{X}_0,\mathcal{X}_1,\mathcal{U}_0, \mathcal{M}(x)$
\Ensure \eqref{eq:rank} holds
\State Solve~\eqref{eq:stability-ctNPS} for $H(x)$ and $P$ via LMIs
\noindent\Statex\textbf{Return:} CBC $\mathcal{V}(x)$, Controller $u$
\end{algorithmic}
\end{algorithm}

\subsection{Continuous Time Linear Systems}\label{subsec:continuous-time-linear-systems}

We consider continuous-time linear systems (ct-LS) defined as follows:

\begin{definition}
\label{def:system-description-ct-LS}
A ct-LS is described by the ordinary differential equation
\begin{equation}
\label{eq:ct-LS}
\Sigma_c: \dot{x} = Ax+Bu
\end{equation}
where $A\in\mathbb{R}^{n\times n}$ and $B\in\mathbb{R}^{n\times m}$ are unknown, $x\in X$ is a system state, and $u\in U$ is a control input, with $X\subset\mathbb{R}^n$, and $U\subset\mathbb{R}^m$ being the state and input sets, respectively.
\end{definition}

\begin{remark}
We remark that in general ct-NPS can be simplified to the linear system by replacing $\mathcal{M}(x)$ with $x$ and $\mathcal{N}_{0}$ with $\mathcal{X}_{0}$.
\end{remark}

We now present the following lemma, adapted here to ct-LS from the work~\cite{de2019formulas}, to obtain a data-based representation of closed-loop ct-LS~\eqref{def:system-description-ct-LS} with controllers $u=Kx$, where $K\in\mathbb{R}^{m\times n}$ is a matrix, which will be synthesized.

\begin{lemma}[ct-LS Q-Lemma~\cite{de2019formulas}]
\label{lem:Q-ctLS}
Let matrix $Q$ be a $(T\times n)$ matrix such that
\begin{equation}
\label{eq:Q-matrix-ctLS}
\identity_n = \mathcal{X}_{0}Q,
\end{equation}
where $\mathcal{X}_{0}$ is an $(n\times T)$ full row-rank matrix.
If one sets $u=Kx = \mathcal{U}_{0}Qx$, then the closed-loop system $\dot{x}=Ax+Bu$ has the following data-based representation:
\begin{equation}
\label{eq:A+BK=X1TQ-ctLS}
\dot{x} = \mathcal{X}_{1}Qx,\quad\text{equivalently,}\quad A+BK = \mathcal{X}_{1}Q.
\end{equation}
\end{lemma}

Using the above lemma, we know have a data-driven representation of our system using $\mathcal{X}_{1}Qx$, which we will use to design controllers for stability and CBCs in the following theorems.

\subsubsection{Control Barrier Certificates}

\begin{theorem}[Data-Driven ct-LS CBC~\cite{wang2024convex}]
\label{thm:data-ctLS-CBC}
Consider the unknown ct-LS~\eqref{eq:ct-LS}, \emph{i.e.} $\dot{x} = Ax+Bu$, with its data-based representation $\dot{x}=\mathcal{X}_{1}Qx$.
Suppose there exists a positive definite symmetric matrix $P\in\mathbb{R}^{n\times n}$ and relationship $Q=HP$ such that the following conditions are satisfied
\begin{align}
\label{eq:ct_CBC_data1}
x^\top [\mathcal{X}_{0}H]^{-1}x \leq \gamma, &\quad\forall x\in X_I, \\
\label{eq:ct_CBC_data2}
x^\top [\mathcal{X}_{0}H]^{-1}x \geq \lambda, &\quad\forall x\in X_U,
\end{align}
and $\forall x\in X$,
\begin{align}
\label{eq:ct_CBC_data3}
\mathcal{X}_{1}H + H^\top\mathcal{X}_{1}^\top &\leq 0\\
\label{eq:ct_CBC_data0}
P^{-1} = \mathcal{X}_{0}H.
\end{align}
Then $\mathcal{B}(x) = x^\top [\mathcal{X}_{0}H]^{-1}x$ is a CBC and $u = \mathcal{U}_{0}H[\mathcal{X}_{0}H]^{-1}x$ is its corresponding safety controller for the unknown ct-LS.
\end{theorem}

% \begin{corollary}[ct-LS controller design]
% \label{cor:ct-LS-controller}
%     The controller for~\eqref{eq:ct_CBC_data3} can be designed to avoid the bilinearity between $P$ and $Q$ in a hierarchical manner by introducing $Q=HP$ and solving the following equations
%     \begin{equation}
%     \label{eq:ctLS-controller}
%      H^\top\mathcal{X}_{1}^\top+ \mathcal{X}_{1}H \leq 0, \quad P^{-1} = \mathcal{X}_{0}H.
%     \end{equation}
% \end{corollary}

We can again design a ct-LS CBC using a hierarchical approach as outlined in Algorithm~\ref{alg:ct-linear}.

\begin{algorithm}[t]
\caption{Hierarchy for ct-LS CBCs}\label{alg:ct-linear}
\begin{algorithmic}[1]
\Require $\mathcal{X}_0,\mathcal{X}_1,\mathcal{U}_0,X,X_I,X_U$
\Ensure \eqref{eq:rank} holds
\Ensure semi-algebraic $X,X_I,X_U$
\State Solve~\eqref{eq:ct_CBC_data3} and~\eqref{eq:ct_CBC_data0} for $H(x)$ and $P$ via LMIs
%\State Solve~\eqref{eq:Q-matrix-X0} for $Q$
\State Substitute and solve~\eqref{eq:ct_CBC_data1}-\eqref{eq:ct_CBC_data2} via SOS optimization
\noindent\Statex\textbf{Return:} CBC $\mathcal{B}(x)$, Controller $u$
\end{algorithmic}
\end{algorithm}

% \subsection{Sum-of-Squares Formulation}

% We now introduce $L_I(x),L_U(x),L(x)$ as vectors of SOS polynomials. We can solve the following using the SumOfSquares~\cite{Yuan_SumOfSquares_py} toolbox where we also add an additional constraint for the equality. We consider matrix $Q\in\mathbb{R}^{T\times n}$ and symmetric positive definite matrix $P\in\mathbb{R}^{n\times n}$ such that
% \begin{equation}
%     \mathbb{I} = \mathcal{X}_{0}Q
% \end{equation}
% and the following are sum-of-squares
% \begin{align}
%     -x^\top Px -& L_I^\top(x)g_I(x) + \gamma, \\
%         x^\top Px -& L_U^\top(x)g_U(x) + \lambda, \\
%          -[\mathcal{X}_{1}Q + Q^\top\mathcal{X}_{1}^\top] -& L^\top(x)g(x).
% \end{align}

% Then the barrier certificate is given by $\mathcal{B}(x) = x^\top P x$ and the controller by $u = \mathcal{U}_{0}Qx$, we also return $\gamma$ and $\lambda$.

\subsubsection{Stability}
We highlight again that solving equations~\eqref{eq:ct_CBC_data3}-\eqref{eq:ct_CBC_data0} without restricting $X$ gives the ct-LS stability conditions as follows.

\begin{theorem}[ct-LS Stable Controller Design~\cite{de2019formulas}]
\label{thm:ctLS-stable}
A control Lyapunov function $\mathcal{V}(x)=x^\top Px$ guaranteeing stability of the ct-LS~\eqref{eq:ct-LS} can be designed by introducing the new variable
\begin{equation*}
\label{eq:Q=HP-ctLS}
Q=HP,
\end{equation*}
so that any matrices $H\in\mathbb{R}^{T\times n}$, and $P\in\mathbb{R}^{n\times n}$ satisfying
\begin{align}
\label{eq:stability-ctLS}
H^\top\mathcal{X}_{1}^\top + \mathcal{X}_{1}H \prec 0, \quad \mathcal{X}_{0}H=P^{-1}
\end{align}
stabilize~\eqref{eq:ct-LS}.
The controller is given by $u=\mathcal{U}_{0}Qx = \mathcal{U}_{0}H[\mathcal{X}_{0}H]^{-1}x.$
\end{theorem}

These conditions for stability are straightforward to solve using standard linear matrix inequality (LMI) solvers. The psuedocode for ct-NPS stability is given in Algorithm~\ref{alg:ctLS-stab}.

\begin{algorithm}[t]
\caption{Hierarchy for ct-LS Stability}\label{alg:ctLS-stab}
\begin{algorithmic}[1]
\Require $\mathcal{X}_0,\mathcal{X}_1,\mathcal{U}_0$
\Ensure \eqref{eq:rank} holds
\State Solve~\eqref{eq:stability-ctLS} for $H(x)$ and $P$ via LMIs
\noindent\Statex\textbf{Return:} CBC $\mathcal{V}(x)$, Controller $u$
\end{algorithmic}
\end{algorithm}

\subsection{Discrete Time Nonlinear Polynomial Systems}\label{subsec:discrete-time-nonlinear-polynomial-systems}

We consider discrete-time nonlinear polynomial systems (dt-NPS) defined as follows:

\begin{definition}
\label{def:system-description-dt-NPS}
A dt-NPS is described by
\begin{equation}
\label{eq:dt-NPS}
\Sigma_d: x^+ = A\mathcal{M}(x)+Bu
\end{equation}
where $A\in\mathbb{R}^{n\times N}$ and $B\in\mathbb{R}^{n\times m}$ are unknown, $\mathcal{M}(x)\in\mathbb{R}^N$ is a vector of monomials in state $x\in X$, and $u\in U$ is a control input, with $X\subset\mathbb{R}^n$, and $U\subset\mathbb{R}^m$ being the state and input sets, respectively.
\end{definition}

We now present the following lemma, from the work~\cite{samari2024singletrajectory}, to obtain a data-based representation of closed-loop dt-NPS~\eqref{def:system-description-dt-NPS} with controllers $u=K(x)x$, where $K(x)\in\mathbb{R}^{m\times n}$ is a matrix, which will be synthesized.

\begin{lemma}[dt-NPS Q-Lemma~\cite{samari2024singletrajectory}]
\label{lem:Q-dtNPS}
Let $Q(x)$ be a $(T\times n)$ matrix polynomial such that
\begin{equation}
\label{eq:nonlinear-theta=NQ}
\Theta(x) = \mathcal{N}_{0}Q(x),
\end{equation}
where $\Theta(x)$ is a $(N\times n)$ matrix polynomial
\begin{equation}
\label{eq:nonlinear-M=thetax}
\mathcal{M}(x)=\Theta(x)x,
\end{equation}
and where $\mathcal{N}_{0}$ is an $(N\times T)$ full row-rank matrix:
\begin{equation}
\label{eq:data-N0T-dt}
\mathcal{N}_{0} = [\mathcal{M}(x(0)), \mathcal{M}(x(1)), \mathcal{M}(x(2)), \ldots, \mathcal{M}(x(T-1))].
\end{equation} If one sets $u=K(x)x = \mathcal{U}_{0}Q(x)x$, then the closed-loop system $x^+=A\mathcal{M}(x)+Bu$ has the following data-based representation:
\begin{equation*}
x^+ = \mathcal{X}_{1}Q(x)x,
\end{equation*}
equivalently
\begin{equation}
\label{eq:nonlinearA+BK=X1TQ}
A\Theta(x)+BK(x) = \mathcal{X}_{1}Q(x).
\end{equation}
\end{lemma}

Using the above lemma, we now have a data-driven representation of our system using $\mathcal{X}_{1}Q(x)x$, which we will use to design controllers for CBCs and stability in the following theorems.

\subsubsection{Control Barrier Certificates}

\begin{theorem}[Data-Driven dt-NPS CBC~\cite{samari2024singletrajectory}]
\label{thm:data-dtNPS-CBC}
Consider the unknown dt-NPS~\eqref{eq:dt-NPS}, \emph{i.e.} $x^+ = A\mathcal{M}(x)+Bu$, with its data-based representation $x^+=\mathcal{X}_{1}Q(x)x$.
Suppose there exists a positive definite symmetric matrix $P\in\mathbb{R}^{n\times n}$ and relationship $Q(x) = H(x)P$ such that the following conditions are satisfied
\begin{align}
\label{eq:nonlinear-safe_CBC_data1}
x^\top Px \leq \gamma, &\quad\forall x\in X_I, \\
\label{eq:nonlinear-safe_CBC_data2}
x^\top Px \geq \lambda, &\quad\forall x\in X_U,
\end{align}
and $\forall x\in X$,
\begin{align}
\label{eq:nonlinear-safe_CBC_data3}
\begin{bmatrix}
P^{-1}              & H(x)^\top \mathcal{X}_{1}^\top \\
\mathcal{X}_{1}H(x) & P^{-1}
\end{bmatrix} \geq 0,\\
\label{eq:nonlinear-safe_CBC_data0}
\Theta(x)P^{-1} = \mathcal{N}_{0}H(x).
\end{align}
Then $\mathcal{B}(x) = x^\top Px$ is a $k$-CBC and $u = \mathcal{U}_{0}H(x)Px$ is its corresponding safety controller for the unknown dt-NPS.
\end{theorem}

%\BW{Substitute $H=QP^{-1}$.}
% Since~\eqref{eq:nonlinear-safe_CBC_data3} contains unknown matrices $Q(x)$ and $P$ there are bilinearities that should be resolved before solving. One hierarchical method is to find any $Q(x)$ from~\eqref{eq:nonlinear-theta=NQ} and then solve for $P$. We raise the following corollary to show a second method for resolving~\eqref{eq:nonlinear-safe_CBC_data3} simultaneously for $P$ and $Q(x)$, while creating
We use the following hierarchical method for finding the CBC by first solving~\eqref{eq:nonlinear-safe_CBC_data3}-\eqref{eq:nonlinear-safe_CBC_data0} followed by~\eqref{eq:nonlinear-safe_CBC_data1}-\eqref{eq:nonlinear-safe_CBC_data2} afterwards.
A temporary variable $Z=P^{-1}$ can be considered during the solving.
The psuedocode algorithm is described in Algorithm~\ref{alg:dt-nonlinear}.

\begin{algorithm}[t]
\caption{Hierarchy for dt-NPS CBCs}\label{alg:dt-nonlinear}
\begin{algorithmic}[1]
\Require $\mathcal{X}_0,\mathcal{X}_1,\mathcal{U}_0,X,X_I,X_U, \mathcal{M}(x)$
\Ensure \eqref{eq:rank} holds
\Ensure semi-algebraic $X,X_I,X_U$
\State Solve~\eqref{eq:nonlinear-M=thetax} for $\Theta(x)$
\State Substitute $\Theta(x)$ in~\eqref{eq:nonlinear-theta=NQ}
\State Solve~\eqref{eq:nonlinear-safe_CBC_data3} and~\eqref{eq:nonlinear-safe_CBC_data0} for $H(x)$ and $P$ via LMIs
%\State Solve~\eqref{eq:Q-matrix-X0} for $Q$
\State Substitute $P$ and solve~\eqref{eq:nonlinear-safe_CBC_data1}-\eqref{eq:nonlinear-safe_CBC_data2} via SOS optimization
\noindent\Statex\textbf{Return:} CBC $\mathcal{B}(x)$, Controller $u$
\end{algorithmic}
\end{algorithm}

% \begin{corollary}[CBC Controller Design]
% \label{cor:dt-NPS-controller}
% We consider matrix $H(x)\in\mathbb{R}^{T\times n}$ and symmetric positive definite matrix $P\in\mathbb{R}^{n\times n}$. We set $Z=P^{-1}$ and $Q(x)Z=H(x)$, such that
% \begin{equation}
% \label{eq:Z=X0H}
%     \Theta(x)Z = \mathcal{N}_{0}H(x)
% \end{equation}
% then~\eqref{eq:safe_CBC_data3} can be equivalently represented by
% \begin{equation}
% \label{eq:SchurZ-dtNPS}
%     \begin{bmatrix}
%             Z &  H(x)^\top \mathcal{X}_{1}^\top \\
%             \mathcal{X}_{1}H(x) & Z
%         \end{bmatrix} \geq 0,\quad \forall x\in X.
% \end{equation}
% The controller is thus $u=\mathcal{U}_{0}H(x)Z^{-1}x$.
% \end{corollary}

\subsubsection{Stability}

\begin{theorem}[dt-NPS Stable Controller Design]
\label{thm:dtNPS-stable}
A control Lyapunov function $\mathcal{V}(x)=x^\top Px$ guaranteeing stability of the dt-NPS~\eqref{eq:dt-NPS} can be designed by introducing the new variable
\begin{equation*}
\label{eq:N0H=ThetaP}
Q(x)Z=H(x),
\end{equation*}
where $Z=P^{-1}$ so that any matrices $H(x)\in\mathbb{R}^{T\times n}$, $\Theta(x)\in\mathbb{R}^{N\times n}$, $P\in\mathbb{R}^{n\times n}$ and $Z\in\mathbb{R}^{n\times n}$ satisfying
\begin{align}
\label{eq:schur-stability-dtNPS}
\begin{bmatrix}
Z                    & H(x)^\top\mathcal{X}_{1}^\top \\
\mathcal{X}_{1} H(x) & Z
\end{bmatrix} \succ 0, \quad \mathcal{N}_{0}H(x)=\Theta(x)Z
\end{align}
stabilize~\eqref{eq:dt-NPS}.
The controller is given by $u=\mathcal{U}_{0}H(x)Z^{-1}x.$
\end{theorem}

Solving the stability equation~\eqref{eq:schur-stability-dtNPS} is straightforward using standard semidefinite programming solvers such as SEDUMI or Mosek,~\BW{cite whichever we used}. The psuedocode for dt-NPS stability is given in Algorithm~\ref{alg:dt-stab}.

\begin{algorithm}[t]
\caption{Hierarchy for dt-NPS Stability}\label{alg:dt-stab}
\begin{algorithmic}[1]
\Require $\mathcal{X}_0,\mathcal{X}_1,\mathcal{U}_0, \mathcal{M}(x)$
\Ensure \eqref{eq:rank} holds
\State Solve~\eqref{eq:nonlinear-M=thetax} for $\Theta(x)$
\State Solve~\eqref{eq:schur-stability-dtNPS} for $H(x)$ and $Z$ via LMIs
\noindent\Statex\textbf{Return:} CBC $\mathcal{V}(x)$, Controller $u$
\end{algorithmic}
\end{algorithm}

% \subsection{Sum-of-Squares Formulation}

% We now introduce $L_I(x),L_U(x),L(x)$ as vectors of SOS polynomials. We can solve the following using the SumOfSquares~\cite{Yuan_SumOfSquares_py} toolbox where we also add an additional constraint for the equality. We consider matrix polynomial $H(x)\in\mathbb{R}^{T\times N}$ and symmetric positive definite matrix $P\in\mathbb{R}^{n\times n}$ such that
% \begin{equation}
%     \Theta(x)P^{-1} = \mathcal{N}_{0}H(x)
% \end{equation}
% and the following are sum-of-squares
% \begin{align}
%     -x^\top Px -& L_I^\top(x)g_I(x) + \gamma, \\
%         x^\top Px -& L_U^\top(x)g_U(x) + \lambda, \\
%          \begin{bmatrix}
%             P^{-1} & H(x)^\top\mathcal{X}_{1}^\top \\
%             \mathcal{X}_{1}H(x) & P^{-1}
%         \end{bmatrix} -& L^\top(x)g(x).
% \end{align}

% \JG{For solving 4.18, we can assume that $P^{-1} = Z$, so we don't need to repeat that before and after}\newline
% To solve first find solutions to
% \begin{equation*}
%     \Theta(x)Z = \mathcal{X}_{0}H(x)
% \end{equation*}
% and
% \begin{equation*}
%     \begin{bmatrix}
%             Z & H(x)^\top\mathcal{X}_{1}^\top \\
%             \mathcal{X}_{1}H(x) & Z
%         \end{bmatrix}\succ 0
% \end{equation*}
% then solve $P = Z^{-1}$ and solve the sum of squares conditions to find $\gamma$ and $\lambda$. Then the barrier certificate is given by $\mathcal{B}(x) = x^\top P x$ and the controller by $u = \mathcal{U}_{0}H(x)[\mathcal{N}_{0}H(x)]^{-1}x$, we also return $\gamma$ and $\lambda$.

\subsection{Discrete Time Linear Systems}\label{subsec:discrete-time-linear-systems}

We consider discrete-time linear systems (dt-LS) defined as follows:

\begin{definition}
\label{def:system-description-dt-LS}
A dt-LS is described by
\begin{equation}
\label{eq:dt-LS}
\Sigma_d: x^+ = Ax+Bu
\end{equation}
where $A\in\mathbb{R}^{n\times n}$ and $B\in\mathbb{R}^{n\times m}$ are unknown, $x\in X$ is a system state, and $u\in U$ is a control input, with $X\subset\mathbb{R}^n$, and $U\subset\mathbb{R}^m$ being the state and input sets, respectively.
\end{definition}

\begin{remark}
As it was with ct-NPS to ct-LS, we remark that in general the results for dt-NPS can be simplied to linear systems by replacing $\mathcal{M}(x)$ with $x$, and $\mathcal{N}_{0}$ with $\mathcal{X}_{0}$.
\end{remark}

We now present the following lemma, adapted here to dt-LS from the work~\cite{de2019formulas}, to obtain a data-based representation of closed-loop dt-LS~\eqref{def:system-description-dt-LS} with controllers $u=Kx$, where $K\in\mathbb{R}^{m\times n}$ is a matrix, which will be synthesized.

\begin{lemma}[dt-LS Q-Lemma~\cite{de2019formulas}]
\label{lem:Q-dtLS}
Let matrix $Q$ be a $(T\times n)$ matrix such that
\begin{equation}
\label{eq:Q-matrix-dtLS}
\identity_n = \mathcal{X}_{0}Q,
\end{equation}
where $\mathcal{X}_{0}$ is an $(n\times T)$ full row-rank matrix.
If one sets $u=Kx = \mathcal{U}_{0}Qx$, then the closed-loop system $x^+=Ax+Bu$ has the following data-based representation:
\begin{equation}
\label{eq:A+BK=X1TQ-dtLS}
x^+ = \mathcal{X}_{1}Qx,\quad\text{equivalently,}\quad A+BK = \mathcal{X}_{1}Q.
\end{equation}
\end{lemma}

We use the above lemma, to describe our system in terms of its data-driven representation $\mathcal{X}_{1}Qx$ and use that representation in the following theorems.

\subsubsection{Control Barrier Certificate}

\begin{theorem}[Data-Driven dt-LS CBC]
\label{thm:data-dtLS-CBC}
Consider the unknown dt-LS~\eqref{eq:dt-LS}, \emph{i.e.} $x^+ = Ax+Bu$, with its data-based representation $x^+=\mathcal{X}_{1}Qx$.
Suppose there exists a positive definite symmetric matrix $P\in\mathbb{R}^{n\times n}$ and relationship $Q=HP$ such that the following conditions are satisfied
\begin{align}
\label{eq:safe_CBC_data1}
x^\top Px \leq \gamma, &\quad\forall x\in X_I, \\
\label{eq:safe_CBC_data2}
x^\top Px \geq \lambda, &\quad\forall x\in X_U,
\end{align}
and $\forall x\in X$,
\begin{align}
\label{eq:safe_CBC_data3}
\begin{bmatrix}
P^{-1}           & H^\top\mathcal{X}_{1}^\top \\
\mathcal{X}_{1}H & P^{-1}
\end{bmatrix} \geq 0, \\
\label{eq:safe_CBC_data0}
P^{-1} = \mathcal{X}_{0}H.
\end{align}
Then $\mathcal{B}(x) = x^\top Px$ is a CBC and  $u = \mathcal{U}_{0}HPx$ is its corresponding safety controller for the unknown dt-LS.
\end{theorem}

% Since~\eqref{eq:safe_CBC_data3} contains unknown matrices $Q$ and $P$ there are bilinearities that should be resolved before solving. One hierarchical method is to find any $Q$ from~\eqref{eq:Q-matrix-dtLS} and then solve for $P$. We raise the following corollary to show a second method for resolving~\eqref{eq:safe_CBC_data3} simultaneously for $P$ and $Q$, while creating a
By substituting $Z=P^{-1}$, the following hierarchical method is used for finding the CBC by solving~\eqref{eq:safe_CBC_data3}-\eqref{eq:safe_CBC_data0} first to find $H$ and $P^{-1}$ followed by solving~\eqref{eq:safe_CBC_data1}-\eqref{eq:safe_CBC_data2} afterwards. The psuedocode algorithm for this is described in Algorithm~\ref{alg:dt-linear}.

\begin{algorithm}[t]
\caption{Hierarchy for dt-NPS CBCs}\label{alg:dt-linear}
\begin{algorithmic}[1]
\Require $\mathcal{X}_0,\mathcal{X}_1,\mathcal{U}_0,X,X_I,X_U$
\Ensure \eqref{eq:rank} holds
\Ensure semi-algebraic $X,X_I,X_U$
\State Solve~\eqref{eq:safe_CBC_data3} and~\eqref{eq:safe_CBC_data0} for $H(x)$ and $P$ via LMIs
%\State Solve~\eqref{eq:Q-matrix-X0} for $Q$
\State Substitute and solve~\eqref{eq:safe_CBC_data1}-\eqref{eq:safe_CBC_data2} via SOS optimization
\noindent\Statex\textbf{Return:} CBC $\mathcal{B}(x)$, Controller $u$
\end{algorithmic}
\end{algorithm}



% \begin{corollary}[CBC Controller Design]
% \label{cor:dt-LS-controller}
% We consider matrix $H\in\mathbb{R}^{T\times n}$ and symmetric positive definite matrix $P\in\mathbb{R}^{n\times n}$. We set $Z=P^{-1}$ and $Q=HP$, such that
% \begin{equation}
% \label{eq:Z=X0Hdt}
%     Z = \mathcal{X}_{0}H
% \end{equation}
% then~\eqref{eq:safe_CBC_data3} can be equivalently represented by
% \begin{equation}
% \label{eq:SchurZ-dtLS}
%     \begin{bmatrix}
%             Z & H^\top\mathcal{X}_{1}^\top \\
%             \mathcal{X}_{1}H & Z
%         \end{bmatrix} \geq 0,\quad \forall x\in X.
% \end{equation}
% The controller is thus $u=\mathcal{U}_{0}H[\mathcal{X}_{0} H]^{-1}x$.
% \end{corollary}

% \subsection{Sum-of-Squares Formulation}

% We now introduce $L_I(x),L_U(x),L(x)$ as vectors of SOS polynomials. We can solve the following using the SumOfSquares~\cite{Yuan_SumOfSquares_py} toolbox where we also add an additional constraint for the equality. We consider matrix $H\in\mathbb{R}^{T\times n}$ and symmetric positive definite matrix $P\in\mathbb{R}^{n\times n}$ such that
% \begin{equation}
%     P^{-1} = \mathcal{X}_{0}H
% \end{equation}
% and the following are sum-of-squares
% \begin{align}
%     -x^\top Px -& L_I^\top(x)g_I(x) + \gamma, \\
%         x^\top Px -& L_U^\top(x)g_U(x) + \lambda, \\
%          \begin{bmatrix}
%             P^{-1} & H^\top\mathcal{X}_{1}^\top \\
%             \mathcal{X}_{1}H & P^{-1}
%         \end{bmatrix} -& L^\top(x)g(x).
% \end{align}

% To solve first find solutions to
% \begin{equation*}
%     Z = \mathcal{X}_{0}H
% \end{equation*}
% and
% \begin{equation*}
%     \begin{bmatrix}
%             Z & H^\top\mathcal{X}_{1}^\top \\
%             \mathcal{X}_{1}H & Z
%         \end{bmatrix}\succ 0
% \end{equation*}
% then solve $P = Z^{-1}$ and solve the sum of squares conditions to find $\gamma$ and $\lambda$. Then the barrier certificate is given by $\mathcal{B}(x) = x^\top P x$ and the controller by $u = \mathcal{U}_{0}H[\mathcal{X}_{0}H]^{-1}x$, we also return $\gamma$ and $\lambda$.

\subsubsection{Stability}

Removing the restriction over $X$ for conditions~\eqref{eq:safe_CBC_data3}-\eqref{eq:safe_CBC_data0} gives the stability conditions.

\begin{theorem}[dt-LS Stable Controller Design~\cite{de2019formulas}]
\label{thm:dtLS-stable}
A control Lyapunov function $\mathcal{V}(x)=x^\top Px$ guaranteeing stability of the dt-LS~\eqref{eq:dt-LS} can be designed by introducing the new variable
\begin{equation*}
\label{eq:H=QP}
QZ=H,
\end{equation*}
where $Z=P^{-1}$ and $P\in\mathbb{R}^{n\times n}$ so that any matrices $H\in\mathbb{R}^{T\times n}$, and $Z\in\mathbb{R}^{n\times n}$ satisfying
\begin{align}
\label{eq:schur-stability-dtLS}
\begin{bmatrix}
Z                 & H^\top\mathcal{X}_{1}^\top \\
\mathcal{X}_{1} H & Z
\end{bmatrix} \succ 0, \quad \mathcal{X}_{0}H=Z
\end{align}
stabilize~\eqref{eq:dt-LS}.
The controller is given by $u= \mathcal{U}_{0}H[\mathcal{X}_0H]^{-1}x.$
\end{theorem}

The above theorem can be solved in a straightforward manner using any LMI solver.  The psuedocode for dt-LS stability is given in Algorithm~\ref{alg:dtls-stab}.

\begin{algorithm}[t]
\caption{Hierarchy for dt-NPS Stability}\label{alg:dtls-stab}
\begin{algorithmic}[1]
\Require $\mathcal{X}_0,\mathcal{X}_1,\mathcal{U}_0$
\Ensure \eqref{eq:rank} holds
\State Solve~\eqref{eq:schur-stability-dtLS} for $H(x)$ and $Z$ via LMIs
\noindent\Statex\textbf{Return:} CBC $\mathcal{V}(x)$, Controller $u$
\end{algorithmic}
\end{algorithm}

% \section{System Verification \BW{?}}


\section{Benchmarks and Case Studies}\label{sec:benchmarks-and-case-studies}

We consider the following dynamical systems from the literature as case study examples.

\subsection{Continuous-Time Systems}

\subsubsection{Nonlinear Systems}
We consider the following ct-NPS systems.

\noindent\textbf{Jet Engine}
We consider the nonlinear Moore-Greitzer jet engine model~\cite{krstic1995lean}:
\begin{equation*}
\Sigma_c: \begin{cases}
\dot{x}_1(t) = -x_2(t)-1.5x_1^2(t)-0.5x_1^3(t),\\
\dot{x}_2(t) = x_1(t),
\end{cases}
\end{equation*}
where $x_1=\Phi-1$, $x_2=\Psi - \Lambda -2$, with $\Phi,\Psi,\Lambda$ being, respectively, the mass flow, pressure rise, and a constant. We consider $X = [0.1,1]^2$, $\initial=[0.1,0.5]^2$, and $\unsafe=[0.7,1]^2$. \BW{add details above initial state and trajectory length.}


\subsubsection{Linear Systems}
We consider the following ct-LS systems.

\noindent\textbf{FOSSIL benchmark - High Order 8.}
We consider the following $8$-dimensional benchmark~\cite{abate2021fossil}
\begin{equation*}
\Sigma_c:\begin{cases}
\dot{x}_1(t) = &x_2(t),\\
\dot{x}_2(t) = &x_3(t),\\
\dot{x}_3(t) = &x_4(t),\\
\dot{x}_4(t) = &x_5(t),\\
\dot{x}_5(t) = &x_6(t),\\
\dot{x}_6(t) = &x_7(t),\\
\dot{x}_7(t) = &x_8(t),\\
\dot{x}_8(t) = &-20x_8(t)-170x_7(t)-800x_6(t) - 2273x_5(t)\\ &-3980x_4(t) - 4180x_3(t)  - 2400x_2(t) - 576x_1(t),
\end{cases}
\end{equation*}
with the state space $X=[-2.2,2.2]^8$, initial region $\initial=[0.9,1.1]^8$, and unsafe region $\unsafe=[-2.2,-1.8]^8$. \BW{add details above initial state and trajectory length.}


\subsection{Discrete-Time Systems}

\subsubsection{Nonlinear Systems}
We consider the following dt-NPS systems.

\noindent\textbf{Lorenz Attractor}
We consider the Lorenz attractor a well studied dynamical system with chaotic behavior. The map has dynamics
\begin{equation*}
\Sigma : \begin{cases}
x_1(k+1) &= x_1(k) + \tau\sigma (x_1(k) + x_2(k)), \\
x_2(k+1) &= x_2(k) +\\ &\quad\tau (\rho x_1(k) - x_2(k) - x_1(k)x_3(k) + u(k)), \\
x_3(k+1) &= x_3(k) + \tau (x_1(k)x_2(k)-\beta x_3(k)),
\end{cases}
\end{equation*}
where $\rho=28, \sigma=10,\beta=\frac{8}{3}, tau=10^{-3}$. We consider the state space $X=[-5,5]^3$, initial set $X_I=[-1, 1]^3$ and two unsafe sets $X_U=[-5,-2.5]^3\cup[2.5,5]^3$. We consider monomials from the set $\mathcal{M}(x)=$ \begin{align*}
[x_1(k)~&x_2(k)~x_3(k)~x_1(k)x_2(k)~ x_2x_3(k)~x_1(k)x_3(k)]^\top,
\end{align*}
and collect data $\mathcal{X}_0$ and $\mathcal{X}_1$ with time horizon $T=50$, equivalently $0.05$s, from initial point $(0.5, 0.5,0.5)$ and choose random inputs along the evolution of the trajectory from the set $U=[-100,100]$.

\noindent\BW{\textbf{Second Nonlinear}}

\subsubsection{Linear Systems}%
We consider the following dt-LS systems.

\noindent\textbf{RLC Circuit.}
\begin{align*}
\Sigma : \begin{cases}
i(k+1) = i(k) + \tau(-\frac{R}{L}i(k) - \frac{1}{L}v(k)) + u_1(k), \\
v(k+1) = v(k) + \tau(\frac{1}{C}i(k)) + u_2(k),
\end{cases}
\end{align*}
We consider the safety of an RLC Circuit, based on~\cite{anand2022kstochastic}, with the dynamics given above, where $i(k)$ denotes the current at time $k$, $v(k)$ is the voltage, $\tau=0.5$s is the sampling time, $R=2\omega$ is the series resistance, $L=9$H is the series inductance, $C=0.5$F is the capacitance of the circuit. We use hypercubes as the state space of the system $X=[-2,2]\times[-4,4]$, initial set $X_I=[0,0.5]\times[0,1]$, and unsafe set $X_U=[1,2]\times[-4,4]$. We construct $\mathcal{X}_{0},\mathcal{U}_{0}$ and $\mathcal{X}_{1}$ by taking a $15$s time horizon trajectory, with initial state $(0,0)$ and random inputs along the evolution of the trajectory from the set $U=[-1,1]\times[-1,1]$.

\noindent\textbf{DC Motor.}
\begin{align*}
%\label{eq:DC-motor-example}
\Sigma : \begin{cases}
x_1(k+1) = x_1(k) - \tau(\frac{R}{L}x_1(k) + \frac{k_{dc}}{L}x_2(k)) + u_1(k), \\
x_2(k+1) = x_2(k) + \tau(\frac{k_{dc}}{J}x_1(k) - \frac{b}{J}x_2(k)) + u_2(k),
\end{cases}
\end{align*}
We also consider the safe operation of a DC Motor, based on~\cite{adewuyi2013dc}, with the dynamics given above where $x_1,x_2,R=1,L=0.01,J=0.01$ are the armature current, the rotational speed of the shaft, the electrical resistance, the electrical inductance, and the moment of inertia of the rotor, respectively. In addition, $\tau=0.01$, $b=1$, and $k_{dc}=0.01$, represent, respectively, the sampling time, the motor torque, and the back electromotive force. We use hypercubes as the state space of the system $X=[0.1,0.5]\times[0.1,1]$, initial set $X_I=[0.1,0.4]\times[0.1,0.55]$, and unsafe set $X_U=[0.45,0.5]\times[0.6,1]$. We first construct the matrices $\mathcal{X}_{0},\mathcal{U}_{0}$ and $\mathcal{X}_{1}$ by taking a trajectory with time horizon $15$s. We construct $\mathcal{X}_{0},\mathcal{U}_{0}$ and $\mathcal{X}_{1}$ by taking a $15$s time horizon trajectory, with initial state $(0,0)$ and random inputs along the evolution of the trajectory from the set $U=[-0.1,0.1]\times[-0.1,0.1]$.

\noindent\textbf{Room Temperature System.}
\begin{equation*}
\Sigma_d:\begin{cases}
x_1(k+1) = (1 - \tau(\alpha + \alpha_{e1}))x_1(k) + \tau\alpha x_2(k) + \tau\alpha_{e1} T_e,\\
x_2(k+1) = (1 - \tau(\alpha + \alpha_{e2}))x_2(k) + \tau\alpha x_1(k) + \tau\alpha_{e2}T_e,
\end{cases}
\end{equation*}
We consider the two room system from the FOSSIL benchmarks~\cite{abate2021fossil}, with dynamics above, where the discretization parameter $\tau = 5$, heat exchange constants $\alpha = 5\times 10^{-2}, \alpha_{e1} = 5\times 10^{-3}, \alpha_{e2} = 8\times10^{-3}$, and external temperature $T_e = 15$. We consider regions of interest $X=[18,23]^2$, $X_I=[18,19.75]^2$, and $X_U=[22,23]$. \BW{add details above initial state and trajectory length.} This is a verification example as no control inputs are present and no controller is designed.

\noindent\textbf{Two Tank System.}
\begin{equation*}
\Sigma_d^\varsigma\!:\begin{cases}
h_1(k+1) = (1-\tau\frac{\alpha_1}{A_1})h_1(k) + \tau\frac{q_1(k)}{A_1},\\
h_2(k+1) = \tau\frac{\alpha_1}{A_2}h_1(k) + (1-\tau\frac{\alpha_2}{A_2})h_2(k) + \tau\frac{q_o(k)}{A_2},
\end{cases}
\end{equation*}
Consider a two-tank system~\cite{ramos2007mathematical}, characterized by the above difference equations where $h_1$, $h_2$ are heights of the fluid in two tanks. Additionally, $\alpha_i$ and $A_i$ are the valve coefficient and area of  tank $i$, and $q_1$ and $q_o$ are the inflow and outflow rate of tank $1$ and $2$, respectively. Furthermore, $\tau=0.1$, $\frac{\alpha_1}{A_1}=1$,$\frac{q_1}{A_1}=4.5$, $\frac{\alpha_1}{A_2}=1$, $\frac{\alpha_2}{A_2}=1$ and $\frac{q_o}{A_2}=-3$. Regions of interest are $X=[1,10]\times[1,10]$, $\initial=[1.75,2.25]\times[1.75,2.25]$, $\unsafe=[9,10]\times[9,10]$. \BW{add details above initial state and trajectory length.} This is a verification example as no control inputs are present and no controller is designed.

\section{Results}\label{sec:results}
- Create a full page table for the four scenarios, each with the safety function, stability barrier function and controller.
- Compare to other tools both in terms of performance and data requirements
- MATLAB w/ these algorithms?
Presumably can cite Behrad's work for dt-NPS?
- Can we cite PRoTECT but state that we're not comparing since we're not dealing with stochastic systems?
(Yes, but we'll do this in the intro's related materials subsection)

\bibliographystyle{ieeetran}
\bibliography{biblio}

\end{document}
